\documentclass[a4paper]{article}
\title{Research Statement}
\author{Mukesh Tiwari}
\date{}
\usepackage{url}
\setlength{\topmargin}{-10mm}
\setlength{\textwidth}{7in}
\setlength{\oddsidemargin}{-8mm}
\setlength{\textheight}{9in}
\setlength{\footskip}{1in}


\begin{document}
\fontsize{12}{15}
\selectfont
\maketitle



Fair elections are the only way to keep a democracy alive. In an election, most countries (election commission) use paper ballots to record 
its citizens' votes (preferences). Election commission then produces the final tally from these votes, 
while many scrutineers --workers of the participating political parties and members of general 
public in some countries, e.g., France-- observe the counting process. 
These scrutineers and paper ballots, both, are crucial to ensure that 
the election is free from fraud. Scrutineers keep the counting process transparent by making sure all the vote counting 
rules are followed, while paper ballots ensure verifiability because in case of a dispute these paper ballots 
can be counted again. Many countries, however, in recent years are introducing computers to conduct some part, or all, of 
election processes because it is cost effective, accessible to disabled voters, faster result, convenient, etc. 
In addition, some voting methods are very complex to count by hand. For example,
single transferable vote used in Australian senate elections, and it may take months to declare the final result of 
a senate election if 
counted by hand. Therefore, the Australian Election Commission scans all the ballots of the senate election and 
uses a (closed source) software program to produce the final tally. Moreover, several cantons in Switzerland use an electronic 
voting system developed by Swiss Post, India uses electronic voting machines, various municipalities in France 
use electronic voting machines, etc.  Nonetheless, there is a growing debate about using electronic voting machines (computers)
because of software bugs leading unintended consequences. For example, Rina Mercuri, 
a candidate in Australia, lost an election because of 
a software bug\footnote{\url{https://www.areanews.com.au/story/3971893/mercuri-robbed/}}, 
Swiss post e-voting source code contained a serious 
bug\footnote{\url{shorturl.at/buTZ8}}, security analysis of Indian electronic 
voting machines have shown many vulnerability \cite{Wolchok:2010:SAI:1866307.1866309}, and 
these few instances are only the tip of the iceberg because many vendors, producing 
e-voting software programs, are not open to criticism\footnote{\url{shorturl.at/bOWZ3}}.
Therefore, it is more imperative than ever  that  we mathematically prove correct (formally verify)  the software programs 
used in elections to make them more trustworthy in order to establish the trust of general members of public
in electronic voting.




\section{PhD Work}
My PhD research was focused on verifying electronic voting, specifically vote-counting schemes, in 
the Coq theorem prover. The goal was to 
bring  three important ingredients, correctness, privacy, and (universal) verifiability, of a paper ballot election to 
an electronic setting (electronic voting). In a paper ballot election, correctness is
ensured by scrutineers, and privacy and verifiability  
come for free because of secret paper ballots.  However, achieving these three desirable properties 
are difficult in 
electronic voting because software programs, used in 
various stages of an election, work in a opaque (blackbox) manner. In this (electronic) setting, 
a software program produces the final tally from cast ballots without any human (scrutineers) involvement, 
other than pressing some 
buttons to run the software program. This opacity can cause harm of various level, including electing a 
wrong winner that is not intended by the voters but due to 
software bugs\footnote{A software bug elected the wrong winner: \url{https://www.areanews.com.au/story/3971893/mercuri-robbed/}}. Most of 
these software programs used across the world by various nations to conduct elections for a public office 
lacks quality measures \cite{10.1145/3014812.3014837, 9152765}. More importantly, these software programs are 
treated as commercial in confidence and therefore,
the members of general public are not allowed to inspect these software programs \cite{AEC:2013:LMM}.





In my thesis, I demonstrated the correctness of a vote-counting software program 
by implementing and proving the correctness of the Schulze method in the Coq theorem 
prover \cite{10.1007/978-3-319-66107-0_26}. 
The Schulze method is a preferential (ranking) voting method where voters rank the participating 
candidates according to their preferences. It is one of the most popular voting method amongst the open-source projects and 
political groups\footnote{\url{https://en.wikipedia.org/wiki/Schulze_method#Users}}.
While no preferential voting scheme can guarantee all
desirable properties that one would like due to Arrow's impossibility theorem \cite{arrow1950difficulty}, 
the Schulze method offers a good compromise with a number of important properties established by economists, 
social choice theorists, and political scientists.  From the Coq formalisation, 
I used Coq's extraction mechanism to get an OCaml implementation to count ballots \cite{10.1007/978-3-319-66107-0_26}.
In addition to correctness, my implementation also
ensured (universal) verifiability by producing a scrutiny sheet 
with the winner of an election. The scrutiny sheet contained all the data to audit the election independently. 
The (extracted) OCaml code, however, was 
very slow, and thus, I wrote another fast implementation that I proved equivalent to the slow one.
The fast implementation was able to count millions of ballots \cite{bennett2017no}.
In both formalisation, I assumed that (preferential) ballots were in plaintext, i.e., 
ranking on every ballot was in a (plaintext) number.  Preferential ballots, 
however, admit ``Italian'' attack \cite{Otten, Benaloh:2009:SSC}. 
If the number of participating candidates are significantly high in 
a preferential ballot election,
then a ballot can be linked to a particular voter if published on a bulletin board.
The attack is: a coercer demands a voter to mark them as first and for the rest of candidates
in a given order (permutation). Later, the coercer checks if that the order appears 
on the bulletin board or not. In order to
avoid this attack on the Schulze method, I used homomorphic encryption to count the (encrypted) ballots, without decrypting 
any individual ballot. Moreover, I addressed verifiability by generating a scrutiny sheet (certificate) 
augmented with zero-knowledge-proofs for various claims, e.g., honest decryption, honest shuffle,  
during the counting \cite{10.1007/978-3-030-41600-3_4}. 
Finally, I worked on a scrutiny-sheet checker for an approval voting election,
International Association of Cryptologic Research (IACR) election \cite{10.1145/3319535.3354247}, 
and, as a future work, I would like to develop a verified scrutiny-sheet checker for encrypted 
ballots Schulze election.
In addition, I was involved in the formalisation of single transferable vote, used in the Australian Senate
\cite{10.1007/978-3-030-00419-4_4}.


\section{Current Work at Cambridge and Previous Work at Melbourne}
Currently, I am working as a postdoctoral researcher at the university of Cambridge. 
In my current project \emph{Combinators for Algebraic Structures}\footnote{\url{https://www.cl.cam.ac.uk/~tgg22/CAS/}}, 
I am formalising various graph algorithms on \emph{semiring} algebraic 
structure and combinators (functions) to 
combine two, or more, algebraic structures. In this work, I am developing 
a mathematical correct-by-construction \cite{10.1007/978-3-319-66107-0_26} 
framework, in Coq thereom prover, based on theory of generalised 
path-finding algebra \cite{10.1093/imamat/15.2.161, 10.1145/1080091.1080094}. 
In our framework, depending on concrete instantiation 
of semiring operators, the same algorithm can compute shortest path, longest paths, 
widest paths, etc. In fact, the Schulze method is one instance of our framework. 
In addition, this framework can be used in operation
research, given that its underlying principles are graph algorithms. 


At the university of Melbourne, my work was focussed on constant-time implementations, 
a key requirement for many applications including cryptography. 
In particular, I worked on security concurrent separation logic for formally reasoning about 
the information flow properties of a concurrent program. 
I used SecureC, a tool developed at the university of Melbourne, to formalise an email server, 
an auction server, and a location server. 
In addition, I developed a information flow secure gradient descent algorithm (a machine learning 
algorithm) in SecureC for 
trusted execution environment, e.g., Intel SGX and ARM TrustZone to process highly sensitive 
data such as parents' income, race, gender, incarceration time, etc\footnote{https://opportunityinsights.org/}.
This work has been informally presented at PaveTrust workshop\footnote{\url{shorturl.at/hlPQ5}}.
All these works were mathematically proven to leak no sensitive 
information to an attacker\footnote{under submission} observing the execution of a program processing 
some secret data.


\section{Future Work}
My long-term aim is to make formal verification accessible and ubiquitous in 
software development, specifically for the software programs deployed in public domain
that affect common people.
My expertise in \textbf{Theorem Proving, Cryptography, and Election Security}
gives me an unique perspective to solve challenging problems that matter to many democracies 
and its citizens. 

\subsection{Mathematically Proven Correct Cryptographic Algorithms}
	In future, I will focus on developing mathematically proven correct cryptographic 
	algorithms used in electronic voting, blockchain, and secure communication, e.g., 
  	sigma protocols (zero-knowledge-proof), verifiable (shuffling) mix-networks, 
  	multi-party computations, secret sharing, zk-snark, etc., 
	The rationale behind implementing these algorithms is that anyone can use them to construct 
	an utility, e.g., an election scrutiny-sheet checker, 
	a vote-tallying system based on blockchain,
	a verifiable ballot mixing service, an auction server, etc. One of the motivation
	behind this project is to replace the SwissPost Java implementations\footnote{\url{shorturl.at/hJOPU}} 
	with mathematically proven correct Coq 
	implementations\footnote{An ongoing project \url{https://github.com/mukeshtiwari/Dlog-zkp/}}.
	

	

\subsection{Mathematically Proven Correct Vote-Counting Algorithms}
In future, I will focus on developing mathematically proven correct
software programs for vote-counting methods used across the world
such as \textit{Single Transferable Vote (STV), 
First Past the Post (FPTP), Instant-runoff voting(IRV), etc.,} in the Coq theorem prover. 
The rationale is that once we have  mathematically proven correct 
components, anyone --election commission or members of general public-- can use them 
to conduct elections, referendums, and verify elections' outcome 
without worrying about software bugs. The interesting and challenging part 
of this project will be to come up with a method to compute final 
tally on encrypted ballots 


The most challenging part for 
this project will be implementing software programs  
for vote-counting methods such as \textit{Single Transferable Vote (STV), 
First Past the Post (FPTP), Instant-runoff, etc.} on encrypted ballots. Given that 
these voting methods differ from each other, there is no uniform way to compute 
final tally from encrypted ballots. Therefore, producing the final tally from encrypted 
ballots will be a challenging task, while ensuring correctness, privacy, and 
verifiability. The outcome of this project can be used by election commissions and citizens of 
the countries that are using software programs to conduct elections, e.g.,
Australia, Switzerland, Canada, France, etc. 

\subsection{Mathematically Proven Correct Decentralised Application}
I will focus on formally verified decentralised peer-to-peer technical solution, inspired by 
\cite{liu2004linkable, Clarke2001, schimmer2009peer, 10.1145/1866307.1866346}, in the Coq theorem prover which will help 
whistleblowers in leaking documents and exposing corruption without revealing their identities.
Being vocal against the government is one the most fundamental right of any citizen, but many 
authoritative governments do not appreciate dissent of any form. Therefore, it uses 
its powerful machinery to punish the dissident, in the name of national security. 
For example, David McBridge\footnote{\url{https://en.wikipedia.org/wiki/David_McBride_(whistleblower)}}, 
a former Australian Defence Force lawyer,  
is facing a threat of lifetime jail after
leaking the material alleging war crimes by members of the Australia's Special Operations
Task Group in Afghanistan (Australia is ranked very high in 
democracy index\footnote{\url{https://worldpopulationreview.com/country-rankings/democracy-countries}}). 
This research will open the door of collaboration with many groups working in verified 
networking, and verified distributed systems. 

\subsection{Mathematically Proven Correct Social Choice Properties}
I will focus on formally verified (computational) social choice theory in the Coq theorem prover. 
Voting methods admit many properties established by political scientists, social choice theorists, 
and economists. For example, the Schulze method follows Condorcet criterion, reversal symmetry,
polynomial runtime, etc., so when we formalise the Schulze method, or in fact any vote-counting method, 
we can push the boundary of correctness by proving that our 
implementation of the Schulze method also follows all the properties \cite{tiwari2021machine}. 
In addition, we can analyse these voting
methods from computational complexity point of view by if a certain amount of bribing
voters a specified candidate can be made an election's winner \cite{faliszewski2006complexity}. 
This research opens the door of collaboration with political scientists, 
social choice theorists, economists, and game theorists.

\subsection{Mathematically Proven Correct Combinators for Algebraic Structure}
I will focus on formally verified combinators for algebraic structure (CAS) in the Coq theorem prover. 
Currently, CAS formalisation is highly focused on networking protocols, but it can be 
adapted for other areas, e.g., optimisation, clustering, algebraic program 
analysis, etc. In the CAS, we use an abstract algebraic structure 
\emph{semiring} as an underlying structure
for computation and we model various algorithm at the top this 
structure. In this setting, an algorithm can compute different values depending 
on the concrete structure of semiring, e.g., the same algorithm 
can compute shortest path, longest paths, 
data flow of imperative programs, and many more \cite{gondran2008graphs} 
for an appropriate semiring.



My lab will be a very diverse place where students and researchers from formal 
verification, cryptography, 
political science, social choice theory will interact, discuss, 
collaborate on the ideas that matters to democracies and societies.


\bibliography{research-statement-bibliography} 
\bibliographystyle{unsrt}

\end{document}