@INPROCEEDINGS{7114482,
  author={Serdult, Uwe and Germann, Micha and Mendez, Fernando and Portenier, Alicia and Wellig, Christoph},
  booktitle={2015 Second International Conference on eDemocracy and eGovernment (ICEDEG)}, 
  title={{Fifteen years of internet voting in Switzerland [History, Governance and Use]}}, 
  year={2015},
  volume={},
  number={},
  pages={126-132},
  doi={10.1109/ICEDEG.2015.7114482}}


@article{gerlach2009three,
  title={Three case studies from Switzerland: E-voting},
  author={Gerlach, Jan and Gasser, Urs},
  journal={Berkman Center Research Publication No},
  volume={3},
  pages={2009},
  year={2009}
}

@inproceedings{DBLP:conf/ev/Driza-MaurerSTW12,
  author       = {Ardita Driza{-}Maurer and
                  Oliver Spycher and
                  Geo Taglioni and
                  Anina Weber},
  editor       = {Manuel J. Kripp and
                  Melanie Volkamer and
                  R{\"{u}}diger Grimm},
  title        = {{E-voting for Swiss Abroad: {A} Joint Project between the Confederation
                  and the Cantons}},
  booktitle    = {5th International Conference on Electronic Voting 2012, {(EVOTE} 2012),
                  Co-organized by the Council of Europe, Gesellschaft f{\"{u}}r
                  Informatik and E-Voting.CC, July 11-14, 2012, Castle Hofen, Bregenz,
                  Austria},
  series       = {{LNI}},
  volume       = {{P-205}},
  pages        = {173--187},
  publisher    = {{GI}},
  year         = {2012},
  url          = {https://dl.gi.de/20.500.12116/18211},
  timestamp    = {Wed, 13 Jan 2021 11:09:43 +0100},
  biburl       = {https://dblp.org/rec/conf/ev/Driza-MaurerSTW12.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}


@ARTICLE{4454399,
  author={Beroggi, Giampiero E.G.},
  journal={Computer}, 
  title={{Secure and Easy Internet Voting}}, 
  year={2008},
  volume={41},
  number={2},
  pages={52-56},
  doi={10.1109/MC.2008.60}}

@article{reiners2020vote,
  title={{Vote electronique in Switzerland: Comparison of relevant pilot projects}},
  author={Reiners, Markus},
  journal={Journal of Comparative Politics},
  volume={13},
  number={1},
  pages={58--75},
  year={2020},
  publisher={University of Ljubljana, Faculty of Social Sciences}
}


@InProceedings{10.1007/978-3-031-15911-4_4,
author="Haines, Thomas
and Pereira, Olivier
and Teague, Vanessa",
editor="Krimmer, Robert
and Volkamer, Melanie
and Duenas-Cid, David
and R{\o}nne, Peter
and Germann, Micha",
title={{Running the Race: A Swiss Voting Story}},
booktitle="Electronic Voting",
year="2022",
publisher="Springer International Publishing",
address="Cham",
pages="53--69",
abstract="On the 29th of March 2019 the Swiss Federal Chancellery launched 
a review of the procedures surrounding e-voting after numerous flaws 
were discovered in the Scytl-Swiss Post system sVote. On the 5th of 
July 2021 an independent examination of the revised Swiss Post system 
began, with some cantons planning to launch new trials with this system.",
isbn="978-3-031-15911-4"
}


@INPROCEEDINGS{9152765,
  author={Haines, Thomas and Lewis, Sarah Jamie and Pereira, Olivier and Teague, Vanessa},
  booktitle={2020 IEEE Symposium on Security and Privacy (SP)}, 
  title={{How not to prove your election outcome}}, 
  year={2020},
  volume={},
  number={},
  pages={644-660},
  doi={10.1109/SP40000.2020.00048}}

@misc{locher2019analysis,
  title={{Analysis of the cryptographic implementation of the swiss post voting protocol}},
  author={Locher, Philipp and Haenni, Rolf and Koenig, Reto E},
  year={2019},
  publisher={July}
}

@InProceedings{10.1007/978-3-642-22792-9_5,
author="Barthe, Gilles
and Gr{\'e}goire, Benjamin
and Heraud, Sylvain
and B{\'e}guelin, Santiago Zanella",
editor="Rogaway, Phillip",
title={{Computer-Aided Security Proofs for the Working Cryptographer}},
booktitle="Advances in Cryptology -- CRYPTO 2011",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="71--90",
abstract="We present EasyCrypt, an automated tool for elaborating security proofs of cryptographic systems from proof sketches--compact, formal representations of the essence of a proof as a sequence of games and hints. Proof sketches are checked automatically using off-the-shelf SMT solvers and automated theorem provers, and then compiled into verifiable proofs in the CertiCrypt framework. The tool supports most common reasoning patterns and is significantly easier to use than its predecessors. We argue that EasyCrypt is a plausible candidate for adoption by working cryptographers and illustrate its application to security proofs of the Cramer-Shoup and Hashed ElGamal cryptosystems.",
isbn="978-3-642-22792-9"
}

@inproceedings{10.1145/3133956.3134078,
author = {Almeida, Jos\'{e} Bacelar and Barbosa, Manuel and Barthe, Gilles and Blot, Arthur and Gr\'{e}goire, Benjamin and Laporte, Vincent and Oliveira, Tiago and Pacheco, Hugo and Schmidt, Benedikt and Strub, Pierre-Yves},
title = {{}Jasmin: High-Assurance and High-Speed Cryptography}},
year = {2017},
isbn = {9781450349468},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3133956.3134078},
doi = {10.1145/3133956.3134078},
abstract = {Jasmin is a framework for developing high-speed and high-assurance cryptographic software. The framework is structured around the Jasmin programming language and its compiler. The language is designed for enhancing portability of programs and for simplifying verification tasks. The compiler is designed to achieve predictability and efficiency of the output code (currently limited to x64 platforms), and is formally verified in the Coq proof assistant. Using the supercop framework, we evaluate the Jasmin compiler on representative cryptographic routines and conclude that the code generated by the compiler is as efficient as fast, hand-crafted, implementations. Moreover, the framework includes highly automated tools for proving memory safety and constant-time security (for protecting against cache-based timing attacks). We also demonstrate the effectiveness of the verification tools on a large set of cryptographic routines.},
booktitle = {Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security},
pages = {1807–1823},
numpages = {17},
keywords = {safety, constant-time security, verified compiler, cryptographic implementations},
location = {Dallas, Texas, USA},
series = {CCS '17}
}

@software{the_coq_development_team_2019_3476303,
	title        = {{The Coq Proof Assistant, version 8.10.0}},
	author       = {The Coq Development Team},
	year         = 2019,
	month        = oct,
	publisher    = {Zenodo},
	doi          = {10.5281/zenodo.3476303},
	url          = {https://doi.org/10.5281/zenodo.3476303},
	version      = {8.10.0}
}

  


@InProceedings{10.1007/978-3-642-38592-6_5,
author="Bocchi, Laura
and Chen, Tzu-Chun
and Demangeon, Romain
and Honda, Kohei
and Yoshida, Nobuko",
editor="Beyer, Dirk
and Boreale, Michele",
title={{Monitoring Networks through Multiparty Session Types}},
booktitle="Formal Techniques for Distributed Systems",
year="2013",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="50--65",
abstract="In large-scale distributed infrastructures, applications are realised through communications among distributed components. The need for methods for assuring safe interactions in such environments is recognized, however the existing frameworks, relying on centralised verification or restricted specification methods, have limited applicability. This paper proposes a new theory of monitored$\pi$-calculus with dynamic usage of multiparty session types (MPST), offering a rigorous foundation for safety assurance of distributed components which asynchronously communicate through multiparty sessions. Our theory establishes a framework for semantically precise decentralised run-time enforcement and provides reasoning principles over monitored distributed applications, which complement existing static analysis techniques. We introduce asynchrony through the means of explicit routers and global queues, and propose novel equivalences between networks, that capture the notion of interface equivalence, i.e. equating networks offering the same services to a user. We illustrate our static-dynamic analysis system with an ATM protocol as a running example and justify our theory with results: satisfaction equivalence, local/global safety and transparency, and session fidelity.",
isbn="978-3-642-38592-6"
}


@inproceedings{ZFHNY2020,
  author = {Fangyi Zhou and Francisco Ferreira and Raymond Hu and Rumyana Neykova and Nobuko Yoshida},
  title = {{Statically Verified Refinements for Multiparty Protocols}},
  booktitle = {OOPSLA 2020: Conference on Object-Oriented Programming Systems, Languages and Applications},
  series = {PACMPL},
  volume = {4},
  issue = {OOPSLA},
  pages = {148:1--148:30},
  publisher = {ACM},
  year = 2020
}


@InProceedings{10.1007/978-3-642-39799-8_48,
author="Meier, Simon
and Schmidt, Benedikt
and Cremers, Cas
and Basin, David",
editor="Sharygina, Natasha
and Veith, Helmut",
title={{The TAMARIN Prover for the Symbolic Analysis of Security Protocols}},
booktitle="Computer Aided Verification",
year="2013",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="696--701",
abstract="The Tamarin prover supports the automated, unbounded, symbolic analysis of security protocols. It features expressive languages for specifying protocols, adversary models, and properties, and support for efficient deduction and equational reasoning. We provide an overview of the tool and its applications.",
isbn="978-3-642-39799-8"
}

@INPROCEEDINGS{9519392,
  author={Baelde, David and Delaune, Stéphanie and Jacomme, Charlie and Koutsos, Adrien and Moreau, Solène},
  booktitle={2021 IEEE Symposium on Security and Privacy (SP)}, 
  title={{An Interactive Prover for Protocol Verification in the Computational Model}}, 
  year={2021},
  volume={},
  number={},
  pages={537-554},
  doi={10.1109/SP40001.2021.00078}}



@INPROCEEDINGS{BlanchetCSFW01,
  AUTHOR = {Bruno Blanchet},
  TITLE = {{An {E}fficient {C}ryptographic {P}rotocol {V}erifier {B}ased on {P}rolog {R}ules}},
  BOOKTITLE = {14th IEEE Computer Security Foundations Workshop (CSFW-14)},
  PAGES = {82--96},
  YEAR = 2001,
  ADDRESS = {Cape Breton, Nova Scotia, Canada},
  MONTH = JUN,
  PUBLISHER = {IEEE Computer Society}
}
@INPROCEEDINGS{8406615,
  author={Cortier, Veronique and Galindo, David and Turuani, Mathieu},
  booktitle={2018 IEEE European Symposium on Security and Privacy (EuroSP)}, 
  title={{A Formal Analysis of the Neuchatel e-Voting Protocol}}, 
  year={2018},
  volume={},
  number={},
  pages={430-442},
  doi={10.1109/EuroSP.2018.00037}}


@INPROCEEDINGS {basin,
author = {L. Arquint and F. A. Wolf and J. Lallemand and R. Sasse and C. Sprenger and S. N. Wiesner and D. Basin and P. Müller},
booktitle = {2023 2023 IEEE Symposium on Security and Privacy (SP) (SP)},
title = {{Sound Verification of Security Protocols: From Design to Interoperable Implementations}},
year = {2023},
volume = {},
issn = {},
pages = {1077-1093},
abstract = {We provide a framework consisting of tools and metatheorems for the end-to-end verification of security protocols, which bridges the gap between automated protocol verification and code-level proofs. We automatically translate a Tamarin protocol model into a set of I/O specifications expressed in separation logic. Each such specification describes a protocol role&#x27;s intended I/O behavior against which the role&#x27;s implementation is then verified. Our soundness result guarantees that the verified implementation inherits all security (trace) properties proved for the Tamarin model. Our framework thus enables us to leverage the substantial body of prior verification work in Tamarin to verify new and existing implementations. The possibility to use any separation logic code verifier provides flexibility regarding the target language. To validate our approach and show that it scales to real-world protocols, we verify a substantial part of the official Go implementation of the WireGuard VPN key exchange protocol.},
keywords = {protocol-verification;symbolic-security;automated-verification;tamarin;separation-logic;implementation},
doi = {10.1109/SP46215.2023.00061},
url = {https://doi.ieeecomputersociety.org/10.1109/SP46215.2023.00061},
publisher = {IEEE Computer Society},
address = {Los Alamitos, CA, USA},
month = {may}
}

@article{vasconcelos2006type,
  title={{Type checking a multithreaded functional language with session types}},
  author={Vasconcelos, Vasco T and Gay, Simon J and Ravara, Ant{\'o}nio},
  journal={Theoretical Computer Science},
  volume={368},
  number={1-2},
  pages={64--87},
  year={2006},
  publisher={Elsevier}
}

@article{vallecillo2003typing,
  title={Typing the behavior of objects and components using session types},
  author={Vallecillo, Antonio and Vasconcelos, Vasco T and Ravara, Ant{\'o}nio},
  journal={Electronic Notes in Theoretical Computer Science},
  volume={68},
  number={3},
  pages={439--456},
  year={2003},
  publisher={Elsevier}
}

@article{10.1145/3290341,
author = {Fowler, Simon and Lindley, Sam and Morris, J. Garrett and Decova, S\'{a}ra},
title = {{Exceptional Asynchronous Session Types: Session Types without Tiers}},
year = {2019},
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290341},
doi = {10.1145/3290341},
abstract = {Session types statically guarantee that communication complies with a protocol. However, most accounts of session typing do not account for failure, which means they are of limited use in real applications---especially distributed applications---where failure is pervasive. We present the first formal integration of asynchronous session types with exception handling in a functional programming language. We define a core calculus which satisfies preservation and progress properties, is deadlock free, confluent, and terminating. We provide the first implementation of session types with exception handling for a fully-fledged functional programming language, by extending the Links web programming language; our implementation draws on existing work on effect handlers. We illustrate our approach through a running example of two-factor authentication, and a larger example of a session-based chat application where communication occurs over session-typed channels and disconnections are handled gracefully.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {28},
numpages = {29},
keywords = {session types, exceptions, web programming, asynchrony}
}

@InProceedings{10.1007/978-3-642-15375-4_17,
author="Capecchi, Sara
and Castellani, Ilaria
and Dezani-Ciancaglini, Mariangiola
and Rezk, Tamara",
editor="Gastin, Paul
and Laroussinie, Fran{\c{c}}ois",
title={{Session Types for Access and Information Flow Control}},
booktitle="CONCUR 2010 - Concurrency Theory",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="237--252",
abstract="We consider a calculus for multiparty sessions with delegation, enriched with security levels for session participants and data. We propose a type system that guarantees both session safety and a form of access control. Moreover, this type system ensures secure information flow, including controlled forms of declassification. In particular, the type system prevents leaks that could result from an unrestricted use of the control constructs of the calculus, such as session opening, selection, branching and delegation. We illustrate the use of our type system with a number of examples, which reveal an interesting interplay between the constraints used in security type systems and those used in session types to ensure properties like communication safety and session fidelity.",
isbn="978-3-642-15375-4"
}


@INPROCEEDINGS{4271648,
  author={Corin, Ricardo and Denielou, Pierre-Malo and Fournet, Cedric and Bhargavan, Karthikeyan and Leifer, James},
  booktitle={20th IEEE Computer Security Foundations Symposium (CSF'07)}, 
  title={{Secure Implementations for Typed Session Abstractions}}, 
  year={2007},
  volume={},
  number={},
  pages={170-186},
  doi={10.1109/CSF.2007.29}}




  
@INPROCEEDINGS{9581188,
  author={Bhargavan, Karthikeyan and Bichhawat, Abhishek and Do, Quoc Huy and Hosseyni, Pedram and Kusters, Ralf and Schmitz, Guido and Wurtele, Tim},
  booktitle={2021 IEEE European Symposium on Security and Privacy (EuroSP)}, 
  title={{${DY}^{\star}$: A Modular Symbolic Verification Framework for Executable Cryptographic Protocol Code}}, 
  year={2021},
  volume={},
  number={},
  pages={523-542},
  doi={10.1109/EuroSP51992.2021.00042}}


@article{rivest2008notion,
  title={On the notion of ‘software independence’in voting systems},
  author={Rivest, Ronald L},
  journal={Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences},
  volume={366},
  number={1881},
  pages={3759--3767},
  year={2008},
  publisher={The Royal Society London}
}

@inproceedings{10.1145/3446804.3446854,
author = {Miu, Anson and Ferreira, Francisco and Yoshida, Nobuko and Zhou, Fangyi},
title = {Communication-Safe Web Programming in TypeScript with Routed Multiparty Session Types},
year = {2021},
isbn = {9781450383257},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3446804.3446854},
doi = {10.1145/3446804.3446854},
abstract = {Modern web programming involves coordinating interactions between browser clients and a server. Typically, the interactions in web-based distributed systems are informally described, making it hard to ensure correctness, especially communication safety, i.e. all endpoints progress without type errors or deadlocks, conforming to a specified protocol. We present STScript, a toolchain that generates TypeScript APIs for communication-safe web development over WebSockets, and RouST, a new session type theory that supports multiparty communications with routing mechanisms. STScript provides developers with TypeScript APIs generated from a communication protocol specification based on RouST. The generated APIs build upon TypeScript concurrency practices, complement the event-driven style of programming in full-stack web development, and are compatible with the Node.js runtime for server-side endpoints and the React.js framework for browser-side endpoints. RouST can express multiparty interactions routed via an intermediate participant. It supports peer-to-peer communication between browser-side endpoints by routing communication via the server in a way that avoids excessive serialisation. RouST guarantees communication safety for endpoint web applications written using STScript APIs. We evaluate the expressiveness of STScript for modern web programming using several production-ready case studies deployed as web applications.},
booktitle = {Proceedings of the 30th ACM SIGPLAN International Conference on Compiler Construction},
pages = {94-106},
numpages = {13},
keywords = {web programming, API generation, TypeScript, session types, WebSocket, deadlock freedom},
location = {Virtual, Republic of Korea},
series = {CC 2021}
}

@inproceedings{10.1145/3209108.3209122,
author = {Demangeon, Romain and Yoshida, Nobuko},
title = {Causal Computational Complexity of Distributed Processes},
year = {2018},
isbn = {9781450355834},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3209108.3209122},
doi = {10.1145/3209108.3209122},
abstract = {This paper studies the complexity of π-calculus processes with respect to the quantity of transitions caused by an incoming message. First we propose a typing system for integrating Bellantoni and Cook's characterisation of polynomially-bound recursive functions into Deng and Sangiorgi's typing system for termination. We then define computational complexity of distributed messages based on Degano and Priami's causal semantics, which identifies the dependency between interleaved transitions. Next we apply a syntactic flow analysis to typable processes to ensure the computational bound of distributed messages. We prove that our analysis is decidable for a given process; sound in the sense that it guarantees that the total number of messages causally dependent of an input request received from the outside is bounded by a polynomial of the content of this request; and complete which means that each polynomial recursive function can be computed by a typable process.},
booktitle = {Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science},
pages = {344-353},
numpages = {10},
keywords = {computational complexity, causal dependency, type system, flow analysis, concurrent process calculi},
location = {Oxford, United Kingdom},
series = {LICS '18}
}

  
@article{TONINHO201761,
title = {Certifying data in multiparty session types},
journal = {Journal of Logical and Algebraic Methods in Programming},
volume = {90},
pages = {61-83},
year = {2017},
issn = {2352-2208},
doi = {https://doi.org/10.1016/j.jlamp.2016.11.005},
url = {https://www.sciencedirect.com/science/article/pii/S2352220816300864},
author = {Bernardo Toninho and Nobuko Yoshida},
keywords = {Session types, Multiparty session types, Value dependent types},
abstract = {Multiparty session types (MPST) are a typing discipline for ensuring the coordination of multi-agent communication in concurrent and distributed programs. The original MPST framework mainly focuses on the communication aspects of concurrency, unable to capture important data invariants in communicating programs. This work introduces value dependent types to the MPST framework in order to increase its expressiveness for certifying invariants of data exchanged among multiple participants. The key idea is to impose constraints on the exchanged data, which is explicitly witnessed at runtime by proof objects. The enriched MPST framework provides programmers with a precise global description of the interaction and data dependent patterns, from which local (data dependent) descriptions can be automatically generated for each endpoint, faithfully capturing at a local level the global data constraints. The framework ensures the absence of communication errors and guarantees communication progress in well-typed multiparty sessions. We also develop an extension of value dependencies based on proof irrelevance that enables the selective erasure of proof objects at runtime.}
}


  



  

